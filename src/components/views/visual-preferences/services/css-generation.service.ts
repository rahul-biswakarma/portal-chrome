import type { UserPreferences, CSSGenerationOptions, DetectedElement } from '../types';
import { getActiveTab } from '@/utils/chrome-utils';

export class CSSGenerationService {
  async generateCSS(
    preferences: UserPreferences,
    elements: DetectedElement[],
    options: CSSGenerationOptions = {
      minify: false,
      addComments: true,
      useImportant: false,
      respectExistingStyles: true,
    }
  ): Promise<string> {
    const cssRules: string[] = [];

    if (options.addComments) {
      cssRules.push('/* Generated by UI Editor - LLM-based CSS */');
      cssRules.push(`/* Generated at: ${new Date().toISOString()} */`);
    }

    for (const element of elements) {
      const elementPreferences = preferences[element.id];
      if (!elementPreferences) continue;

      const elementCSS = this.generateElementCSSFromLLM(element, elementPreferences, options);
      if (elementCSS) {
        cssRules.push(elementCSS);
      }
    }

    const css = cssRules.join('\n\n');
    return options.minify ? this.minifyCSS(css) : css;
  }

  // New method to update individual preference CSS
  async updatePreferenceCSS(
    elementId: string,
    preferenceId: string,
    userValue: unknown,
    element: DetectedElement,
    currentCSSContent: string
  ): Promise<string> {
    const preference = element.availablePreferences.find(p => p.id === preferenceId);
    if (!preference || !preference.metadata) return currentCSSContent;

    // Generate CSS for this specific preference
    const css = this.generateCSSForPreference(preference, userValue, {
      minify: false,
      addComments: false,
      useImportant: false,
      respectExistingStyles: true,
    });

    // Create unique identifier for this preference
    const prefId = `${elementId}:${preferenceId}`;
    const startComment = `/* PREF:${prefId}:START */`;
    const endComment = `/* PREF:${prefId}:END */`;

    // Check if this preference already exists in the CSS
    const startIndex = currentCSSContent.indexOf(startComment);
    const endIndex = currentCSSContent.indexOf(endComment);

    if (startIndex !== -1 && endIndex !== -1) {
      // Replace existing preference CSS
      const beforeCSS = currentCSSContent.substring(0, startIndex);
      const afterCSS = currentCSSContent.substring(endIndex + endComment.length);

      if (css.trim()) {
        // Update with new CSS
        return `${beforeCSS}${startComment}\n${css}\n${endComment}${afterCSS}`;
      } else {
        // Remove the preference (user reset to default)
        return `${beforeCSS}${afterCSS}`.replace(/\n\n\n+/g, '\n\n').trim();
      }
    } else {
      // Add new preference CSS
      if (css.trim()) {
        const newSection = `\n\n${startComment}\n${css}\n${endComment}`;
        return currentCSSContent + newSection;
      }
      return currentCSSContent;
    }
  }

  private generateElementCSSFromLLM(
    element: DetectedElement,
    preferences: Record<string, unknown>,
    options: CSSGenerationOptions
  ): string {
    const rules: string[] = [];

    if (options.addComments) {
      rules.push(`/* ${element.description} */`);
    }

    // Process each preference for this element
    element.availablePreferences.forEach(preference => {
      const userValue = preferences[preference.id];

      // Only generate CSS if the value has been explicitly set AND is different from default
      if (userValue === undefined || userValue === null) return;

      // Check if the user value is different from the default value
      const defaultValue = preference.currentValue;
      if (userValue === defaultValue) return;

      const css = this.generateCSSForPreference(preference, userValue, options);
      if (css) {
        rules.push(css);
      }
    });

    return rules.length > 0 ? rules.join('\n') : '';
  }

  private generateCSSForPreference(
    preference: DetectedElement['availablePreferences'][0],
    userValue: unknown,
    options: CSSGenerationOptions
  ): string {
    const metadata = preference.metadata;
    if (!metadata) return '';

    let css = '';

    switch (preference.type) {
      case 'toggle':
        // For toggles, use cssOnTrue or cssOnFalse based on the boolean value
        if (typeof userValue === 'boolean') {
          css = userValue ? metadata.cssOnTrue || '' : metadata.cssOnFalse || '';
        }
        break;

      case 'dropdown':
        // For dropdowns, use cssOptions based on the selected value
        if (typeof userValue === 'string' && metadata.cssOptions) {
          css = metadata.cssOptions[userValue] || '';
        }
        break;

      case 'layout-selector':
        // Same as dropdown for layout selectors
        if (typeof userValue === 'string' && metadata.cssOptions) {
          css = metadata.cssOptions[userValue] || '';
        }
        break;

      case 'slider':
        // For sliders, we might need to interpolate CSS values
        // This would need custom handling per preference
        break;

      case 'color-picker':
        // For color pickers, we'd replace color values in the CSS template
        // This would need custom handling per preference
        break;

      default:
        console.warn(`Unsupported preference type: ${preference.type}`);
    }

    // Validate and fix CSS - ensure it has actual selectors
    if (css && metadata.targetClasses && metadata.targetClasses.length > 0) {
      // If the CSS doesn't contain any of the target classes, it might be malformed
      const containsTargetClass = metadata.targetClasses.some(className =>
        css.includes(`.${className}`)
      );

      if (!containsTargetClass) {
        console.warn(`Visual Preferences: CSS template missing target classes, auto-fixing...`);

        // Try to extract CSS properties and apply them to actual target classes
        const cssDeclarations = this.extractCSSDeclarations(css);
        if (cssDeclarations) {
          css = metadata.targetClasses
            .map(className => `.${className} { ${cssDeclarations} }`)
            .join('\n');
        }
      }
    }

    // Add !important if specified
    if (css && options.useImportant) {
      css = css.replace(/;/g, ' !important;');
    }

    return css;
  }

  // Helper method to extract CSS declarations from potentially malformed CSS
  private extractCSSDeclarations(css: string): string | null {
    // Try to extract everything between { and }
    const match = css.match(/\{([^}]+)\}/);
    if (match && match[1]) {
      return match[1].trim();
    }

    // If no braces found, assume it's just declarations
    if (css.includes(':') && css.includes(';')) {
      return css.trim();
    }

    return null;
  }

  async applyTextReplacements(
    preferences: UserPreferences,
    elements: DetectedElement[]
  ): Promise<void> {
    // Text replacements are now handled by the LLM-generated CSS
    // This method remains for compatibility but may not be needed
    try {
      const tab = await getActiveTab();
      if (!tab.id) return;

      await chrome.scripting.executeScript({
        target: { tabId: tab.id },
        func: (prefs: UserPreferences, elems: DetectedElement[]) => {
          // Apply any text replacements defined in the LLM response
          elems.forEach((element: DetectedElement) => {
            const elementPrefs = prefs[element.id];
            if (!elementPrefs) return;
          });
        },
        args: [preferences, elements],
      });
    } catch (error) {
      console.error('Error applying text replacements:', error);
    }
  }

  private minifyCSS(css: string): string {
    return css
      .replace(/\/\*[\s\S]*?\*\//g, '') // Remove comments
      .replace(/\s+/g, ' ') // Replace multiple whitespace with single space
      .replace(/\s*{\s*/g, '{') // Remove spaces around opening braces
      .replace(/;\s*/g, ';') // Remove spaces after semicolons
      .replace(/\s*}\s*/g, '}') // Remove spaces around closing braces
      .trim();
  }

  // Helper method to extract CSS from LLM-generated preferences
  static extractCSSFromPreferences(
    preferences: UserPreferences,
    elements: DetectedElement[]
  ): { selector: string; css: string }[] {
    const cssBlocks: { selector: string; css: string }[] = [];

    elements.forEach((element: DetectedElement) => {
      const elementPrefs = preferences[element.id];
      if (!elementPrefs) return;

      element.availablePreferences.forEach((pref: DetectedElement['availablePreferences'][0]) => {
        const userValue = elementPrefs[pref.id];
        if (userValue === undefined || userValue === null || !pref.metadata) return;

        let css = '';

        if (pref.type === 'toggle' && typeof userValue === 'boolean') {
          css = userValue ? pref.metadata.cssOnTrue || '' : pref.metadata.cssOnFalse || '';
        } else if (pref.type === 'dropdown' || pref.type === 'layout-selector') {
          if (typeof userValue === 'string' && pref.metadata.cssOptions) {
            css = pref.metadata.cssOptions[userValue] || '';
          }
        }

        if (css && pref.metadata.targetClasses) {
          pref.metadata.targetClasses.forEach((targetClass: string) => {
            cssBlocks.push({
              selector: `.${targetClass}`,
              css: css,
            });
          });
        }
      });
    });

    return cssBlocks;
  }

  // Method to generate preview CSS for a single preference change
  generatePreviewCSS(element: DetectedElement, preferenceId: string, newValue: unknown): string {
    const preference = element.availablePreferences.find(p => p.id === preferenceId);
    if (!preference || !preference.metadata) return '';

    return this.generateCSSForPreference(preference, newValue, {
      minify: false,
      addComments: false,
      useImportant: false,
      respectExistingStyles: false,
    });
  }
}

export const cssGenerationService = new CSSGenerationService();
