import type { UserPreferences, CSSGenerationOptions, DetectedElement } from '../types';
import { getActiveTab } from '@/utils/chrome-utils';

export class CSSGenerationService {
  async generateCSS(
    preferences: UserPreferences,
    elements: DetectedElement[],
    options: CSSGenerationOptions = {
      minify: false,
      addComments: true,
      useImportant: true,
      respectExistingStyles: true,
    }
  ): Promise<string> {
    const cssRules: string[] = [];

    if (options.addComments) {
      cssRules.push('/* Generated by Visual Preferences */');
    }

    for (const element of elements) {
      const elementPreferences = preferences[element.id];
      if (!elementPreferences) continue;

      const elementCSS = this.generateElementCSS(element, elementPreferences, options);
      if (elementCSS) {
        cssRules.push(elementCSS);
      }
    }

    const css = cssRules.join('\n\n');
    return options.minify ? this.minifyCSS(css) : css;
  }

  private generateElementCSS(
    element: DetectedElement,
    preferences: Record<string, unknown>,
    options: CSSGenerationOptions
  ): string {
    const rules: string[] = [];
    const important = options.useImportant ? ' !important' : '';

    if (options.addComments) {
      rules.push(`/* ${element.description} */`);
    }

    // Handle visibility preference
    if (preferences.visibility === false) {
      rules.push(`${element.selector} {`);
      rules.push(`  display: none${important};`);
      rules.push('}');
      return rules.join('\n');
    }

    // Handle layout preferences
    if (preferences.layout) {
      rules.push(this.generateLayoutCSS(element, preferences.layout as string, important));
    }

    // Handle styling preferences
    if (preferences.size) {
      rules.push(this.generateSizeCSS(element, preferences.size as string, important));
    }

    if (preferences.alignment) {
      rules.push(this.generateAlignmentCSS(element, preferences.alignment as string, important));
    }

    if (preferences.columns && element.type === 'card-container') {
      rules.push(this.generateColumnsCSS(element, preferences.columns as string, important));
    }

    // Handle button text replacement
    if (preferences['replace-text'] && element.type === 'button') {
      rules.push(this.generateTextReplacementCSS(element, preferences['replace-text'] as string));
    }

    return rules.filter(rule => rule.trim()).join('\n');
  }

  private generateLayoutCSS(element: DetectedElement, layout: string, important: string): string {
    const rules: string[] = [];

    rules.push(`${element.selector} {`);

    switch (layout) {
      case 'row':
        rules.push(`  display: flex${important};`);
        rules.push(`  flex-direction: row${important};`);
        break;
      case 'column':
        rules.push(`  display: flex${important};`);
        rules.push(`  flex-direction: column${important};`);
        break;
      case 'grid':
        rules.push(`  display: grid${important};`);
        rules.push(`  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr))${important};`);
        rules.push(`  gap: 1rem${important};`);
        break;
    }

    rules.push('}');
    return rules.join('\n');
  }

  private generateSizeCSS(element: DetectedElement, size: string, important: string): string {
    const rules: string[] = [];
    rules.push(`${element.selector} {`);

    switch (size) {
      case 'small':
        if (element.type === 'button') {
          rules.push(`  padding: 0.25rem 0.5rem${important};`);
          rules.push(`  font-size: 0.875rem${important};`);
        }
        break;
      case 'medium':
        if (element.type === 'button') {
          rules.push(`  padding: 0.5rem 1rem${important};`);
          rules.push(`  font-size: 1rem${important};`);
        }
        break;
      case 'large':
        if (element.type === 'button') {
          rules.push(`  padding: 0.75rem 1.5rem${important};`);
          rules.push(`  font-size: 1.125rem${important};`);
        }
        break;
    }

    rules.push('}');
    return rules.join('\n');
  }

  private generateAlignmentCSS(
    element: DetectedElement,
    alignment: string,
    important: string
  ): string {
    const rules: string[] = [];
    rules.push(`${element.selector} {`);
    rules.push(`  text-align: ${alignment}${important};`);
    rules.push('}');
    return rules.join('\n');
  }

  private generateColumnsCSS(element: DetectedElement, columns: string, important: string): string {
    const rules: string[] = [];
    rules.push(`${element.selector} {`);

    if (columns === 'auto') {
      rules.push(`  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr))${important};`);
    } else {
      rules.push(`  display: grid${important};`);
      rules.push(`  grid-template-columns: repeat(${columns}, 1fr)${important};`);
      rules.push(`  gap: 1rem${important};`);
    }

    rules.push('}');
    return rules.join('\n');
  }

  private generateTextReplacementCSS(element: DetectedElement, newText: string): string {
    // This requires JavaScript injection rather than pure CSS
    // We'll handle this in the application service
    return `/* Text replacement for ${element.selector}: "${newText}" - handled by JS */`;
  }

  private minifyCSS(css: string): string {
    return css
      .replace(/\/\*.*?\*\//g, '') // Remove comments
      .replace(/\s+/g, ' ') // Replace multiple spaces with single space
      .replace(/;\s*}/g, '}') // Remove unnecessary semicolons before closing braces
      .replace(/\s*{\s*/g, '{') // Remove spaces around opening braces
      .replace(/;\s*/g, ';') // Remove spaces after semicolons
      .trim();
  }

  async applyTextReplacements(
    preferences: UserPreferences,
    elements: DetectedElement[]
  ): Promise<void> {
    const tab = await getActiveTab();
    if (!tab.id) return;

    const textReplacements = elements
      .filter(el => el.type === 'button' && preferences[el.id]?.['replace-text'])
      .map(el => ({
        selector: el.selector,
        newText: preferences[el.id]['replace-text'] as string,
      }));

    if (textReplacements.length === 0) return;

    await chrome.scripting.executeScript({
      target: { tabId: tab.id },
      func: (replacements: Array<{ selector: string; newText: string }>) => {
        replacements.forEach(({ selector, newText }) => {
          const elements = document.querySelectorAll(selector);
          elements.forEach(element => {
            if (element.textContent !== newText) {
              element.textContent = newText;
            }
          });
        });
      },
      args: [textReplacements],
    });
  }
}

export const cssGenerationService = new CSSGenerationService();
